# C/C++



## 数据结构与算法

## 最大堆和最小堆<br>
堆是完全二叉树，根据节点和左右孩子的大小关系，分为最大堆和最小堆（又称大顶堆和小顶堆）<br>
* 最大堆
  * 每个节点的值都大于等于其左右孩子节点的值
* 最小堆
  * 每个节点的值都小于等于其左右子节点的值


## 平衡二叉树
* 查找的时间复杂度为O(logn)，插入和删除的时间复杂度O(logn)
* 性质
  * 可以是空树
  * 若不为空树，则任意一个子节点的左子树和右子树都是平衡二叉树，且高度差的绝对值不大于1(保证了二叉查找树不会蜕变成链表)

## 2-3树
* 性质
  * 满足二叉搜索树的性质
  * 节点可以存放一个或两个元素
  * 每个节点有两个或三个子节点(一个2结点包含一个元素和两个孩子 一个3结点包含一小一大两个元素和三个孩子)

## 红黑树
* 查找的时间复杂度为O(logn)，插入和删除的时间复杂度O(logn)
* 性质
  * 每个结点非黑即红
  * 根结点为黑色
  * 叶子节点为黑色（叶子节点即实际叶子结点的NULL指针或NULL节点）
  * 若结点为红色，则其子节点一定是黑色（即没有连续的红节点）
  * 对于每个结点，从该结点到其后代叶节点的简单路径上，均包含相同数目的黑色节点（叶子结点要补充两个NULL结点）
* 通过上面五个性质得到结论：通过任意路径从跟结点到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的两倍，因此接近平衡。

* 平衡树和红黑树的区别
  * AVL(平衡二叉树)是高度平衡的，频繁的插入和删除会引起频繁的调整以重新平衡，导致效率下降
  * 红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转，实现起来也更为简单
* 红黑树为什么要保证每条路径上黑色节点数目一致
  * 为了保证每条红黑树最长路径不超过最短路径的两倍
  * 假设一个红黑树T，其到叶节点的最短路径肯定全部是黑色节点（共B个），最长路径肯定有相同个黑色节点（性质5：黑色节点的数量是相等），另外会多几个红色节点。性质4（红色节点必须有两个黑色儿子节点）能保证不会再现两个连续的红色节点。所以最长的路径长度应该是2B个节点，其中B个红色，B个黑色。

## B/B+树的区别
* 以(key，value)二元组来存储信息












