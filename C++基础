1、宏与枚举的区别
  1、宏定义字符常量，不分配内存空间，而枚举是定义变量的一种方式。
  2、宏和枚举之间的差别主要在作用的时期和存储的形式不同，宏是在预处理的阶段进行替换工作的，它替换代码段的文本，程序运行的过程中宏已不存在了。
而枚举是在程序运行之后才起作用的，枚举常量存储在数据段的静态存储区里。宏占用代码段的空间，而枚举除了占用空间，还消耗CPU资源。但也不能就此说宏比枚举好，
如果需要定义非常多的常量，用一条enum {.....}明显比一大堆define更清晰，枚举也可以用来定义一些特殊类型，比如Bool，如：type enum {FALSE,TRUE} Bool;

2、智能指针实现原理
  智能指针(smart pointer)的一种通用实现技术是使用引用计数(reference count)。智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象
共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个
对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数
减少引用计数（如果引用计数减至0，则删除基础对象）。

3、构造函数为什么不能是虚函数？
（1）从存储空间角度
  虚函数对应一个vtable，这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过vtable来调用，
可是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。
（2）从使用角度
  虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要
是虚函数。
（3）从虚函数的作用
  虚函数的作用是在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针
或者引用去调用，因此也就规定构造函数不能是虚函数。

4、类成员函数的重载、覆盖和隐藏区别？
a.成员函数被重载的特征：
（1）相同的范围（在同一个类中）；
（2）函数名字相同；
（3）参数不同；
（4）virtual关键字可有可无。
b.覆盖是指派生类函数覆盖基类函数，特征是：
（1）不同的范围（分别位于派生类与基类）；
（2）函数名字相同；
（3）参数相同；
（4）基类函数必须有virtual关键字。
c.“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）

5、C++虚函数实现机制
  一个拥有virtual成员函数的类拥有一个虚函数表，而该类的每个对象都拥有一个虚指针，指向该类的虚函数表。运行时，通过对象自己的虚指针去索引正确的
虚函数来运行。若基类中的virtual函数返回类型为基类型的引用或者指针，则派生类中重写该函数，需要将返回类型改为派生类类型的引用或者指针。





